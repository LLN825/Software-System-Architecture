# 基础复习架构笔记

## 第一篇、架构设计基础

### 一、概述

#### 1.1**系统架构的概念**

**信息系统架构的定义**

软件系统架构是关于软件系统的结构、行为、属性的高级抽象。

- 系统的结构指的是系统中各个组件之间的关系和组织方式

- 行为指的是系统在运行时的各种操作和响应方式

- 属性则包括系统的可靠性、可维护性、可扩展性、可移植性等方面的特征。

**信息系统的架构三要素**

- 构件：软件系统中的模块，库和组件，它们是构建系统的基本单元。彼此相对独立，通过接口进行彼此间的交互，具有高内聚，低耦合的特点。它们的功能是紧密相连的，而之间的依赖关系则应该是尽可能少的。

- 模式：是软件开发过程中经常出现的重复性问题的解决方案，是经过证实或广泛应用的最佳实践。常见的有MVC模式，AOP模式、IOC模式、还有那些各种各样的设计模式。

- 规划：是在软件系统设计和实现过程中对软件开发的管理和控制。包括项目需求分析、开发周期那排、质量测试保证等方面。合理的规划能够保证系统的开发和维护有着高效且高质的特点。

**信息系统架构的两个层次**

- 概念层次：包括艺术、科学、方法、建设风格，考虑系统的整体架构设计、数据流和控制流等方面，主要确保系统的可扩展性和可维护性。

- 物理层次：包括物理结构、相互作用结果，考虑这些软件、硬件、网络节点结构之间的互联互通，确保系统的高可用性、高性能和IT成本。

#### 1.2 系统架构师的定义与素质

**架构师的定义**

​	系统架构师是系统的设计负责人，是一个负责理解和管理并最终确认和评估非功能性系统需求，给出开发规范，搭建系统实现的核心架构，对整个软件工程、关键构件、接口进行总体设计并澄清关键技术细节的高级技术专家，于此同时还要考虑技术团队的组织协调，有卓越的管理素质以及个人魅力。

- 与产品经理相比：如果把开发软件比作摄制电影’产品经理之于系统架构设计师,就正像编剧之于导演。产品经 理虽然要有—定技术背景但仍应属于“商业人士”,而系统架构设计师则肯定是—个技术专家°

- 与项目经理相比：在—个项目中推动项目发展的是系统架构设计师,而不是项目经理，项目经理的职责只是配合系统架构设计师提供各个方面资源的支持（人、财、物）而已

- 与系统分析师相比：分析师对现有系统的商业效果、开发运维难度、成本性能分析并提出问题。架构师应该对分析师提出的问题、碰到的难题给出解决方案，对重点技术问题进行攻关，提供最强有力的技术保障。

**优秀的架构师应该具备的素质：**

1. 技术演进方向  眼界
2. 业务流程理解  建模
3. 技术选型实现  选型
4. I.T.审计治理    代码
5. 数据架构分析  数分
6. 基础设施资源  运维
7. 信息安全保障  安全
8. 质量保证能力  测试

### 二、计算机基础知识

#### 2.1 操作系统

**定义**

​	操作系统是计算机系统中的核心基础软件，他负责管理和控制计算机系统中的硬件资源和其他软件，合理地组织进程并有效利用资源。它屏蔽了计算机的底层细节，在计算机和用户之间起接口作用。

**操作系统的四大特征**

​	并发性（concurrency）、共享性（sharing）、虚拟性（virtual）、不确定性（non-determinacy） 

> ​	操作系统可以同时处理多个进程，这些进程可以共享计算机的资源，而这些资源则是通过操作系统虚拟出来的，如：CPU时间、内存空间、磁盘空间、网络带宽，并且操作系统运行时存在中断、时钟周期、负载等等不确定因素。

**操作系统的功能**

​	进程管理、文件管理、设备管理、存储管理、作业管理

**典型的操作系统**

​	批处理操作系统、分时操作系统、实时操作系统、网络操作系统、分布式操作系统

**进程和程序**

​	程序是一组指令的集合，是静态的概念。而进程是程序的一次执行，是操作系统进行资源分配、调度和管理的基本单元，由程序、数据、PCB组成，是计算机状态的一个有序集合，是一个动态的概念。

​	一个程序可以形成多个进程，且一个进程可以有多个线程。

> ​	PCB是进程存在的唯一标志，描述了当前进程的基本调度信息和执行信息，它随着进程的创建而生成，随进程的终止而撤销。
>
> ​	线程是多核CPU分配资源的最小单元，它可以共享进程的资源和地址空间，通过线程的活动，进程可以同时多种服务或并行子任务。相比于进程切换，线程的创建和调度更为轻量化，因为无需内存地址空间的切换。

**进程的状态模型**

三态模型：

- 运行态：占用处理器中，正在执行计算。
- 等待态：具备运行条件，等待系统分配资源后运行。
- 阻塞态：不具备运行条件，等待某个事件的完成。

五态模型：

- 运行态
- 等待态（活跃、静止）
- 阻塞态（活跃、静止）

> ”静止“指的是进程被挂起，将所有信息从内存中对换到磁盘区中，使之暂时不参与运行和进程的调度，起到平滑操作系统负荷的作用。

**信号量与PV操作**

​	操作系统中，进程经常会存在互斥和同步，而信号量和PV操作就是用来处理这些关系的。在资源使用之前进行P操作，在资源用完之后进行V操作。

PV操作都是对信号量（S+队列）的操作，具体如下：

P操作：S = S - 1，若S < 0，表示当前没有资源分配给进程，进程进入阻塞队列。

V操作：S = S + 1，若S = 0, 表示阻塞队列中有等待该资源的进程，唤醒队列中的第一个进程。

> ​	互斥控制是为了保护共享资源、不让多个进程同时访问该共享资源。也就是组织多个进程同时进入访问这些资源的代码段，这个代码段被称为 临界区，共享资源被称为临界资源。

**死锁**

​	死锁是指多个进程件互相等待对方的资源，而在得到对方资源之前又不释放自己的资源，对方释放资源还依赖着本进程的继续推进，从而造成循环等待的一种现象。造成死锁有四个必要条件：

​	资源互斥、请求保持、不可剥夺、形成环路

**银行家算法**

​	 在分配资源之前看清楚资源分配后是否会导致系统死锁，即模拟分配并判断该进程对资源的最大需求量是否超过当前系统空闲的资源数。如果会死锁，则不分配资源，否则就分配资源，接纳该进程。

**存储管理**

存储管理的主要任务：有效地控制管理内存，提高内存利用率，扩充内存以及对内存信息实现有效的保护。

操作系统通过存储管理将物理内存抽象为虚拟内存，用户变成所使用的地址是逻辑地址，而实际的地址是物理地址，每次访问内存都需要将逻辑地址转换为物理地址，这种转换是有CPU的内存管理单元MMU完成的，这个过程叫做地址重定向。操作系统在这个过程中创建并维护页表等数据结构，从而支持地址重定向，进而完成内存和磁盘间的信息兑换。

**虚拟存储**

​	虚拟存储是一种计算机内存管理技术，它可以扩展物理内存的大小，使得用户程序可以访问比物理内存更大的地址空间。为了实现虚拟存储，操作系统采用了不同的技术，包括分段技术、分页技术和段页式技术。

- 分段技术

​	将用户程序按照逻辑结构划分成多个段（生成段表），每个段具有独立的地址空间，可以独立地进行存储管理。操作系统为每个段分配一段虚拟地址空间，通过段表将段映射到物理地址。

>  粒度过大，段外碎片降低了利用率

- 分页技术

​	将用户程序和操作系统的内存空间划分成固定大小的页和页框，将虚拟地址空间划分成固定大小的页，将页映射到页框 (页表)，实现地址转换。

> 粒度过小，分页技术的但页表的开销较大。

段页式技术

​	将分段技术和分页技术相结合，将用户程序按照逻辑结构划分成多个段，每个段再按照固定大小的页划分成多个页。段页式技术综合了分段技术和分页技术的优点，可以提高内存的利用率，减少内存碎片和页表的开销

> 需要更复杂的地址转换机制和管理结构。

#### 2.2 数据库系统

**数据库、数据库系统、数据库管理系统**

数据库是指长期存储在计算机内的、有组织的、可共享的数据集合。

数据库系统是指由数据库、软硬件和人员组成的系统，管理的对象是数据。

数据库管理系统是一种操纵和管理数据库的大型软件系统，管理数据库，包括创建、维护、查询和更新数据库中的数据。

**数据库的备份和恢复**

​	备份是指通过数据转储和管理日志文件的方法来冗余数据。恢复是指在故障发生后，由数据库管理者或系统自身重新装入数据的副本或日志文件副本，再由数据库执行操作。

>  几种备份模式: 静态备份、动态备份、全量备份、增量备份

​	故障可能会造成一些数据的不一致或者丢失。数据库有四类常见的故障，事务故障、系统故障、介质故障、计算机病毒。事务故障的通过日志来恢复，它有两种操作：撤销事务和重做事务。介质或系统的故障则需要通过副本进行恢复。

> UNDO操作是指回滚事务的操作，即将已经执行的事务的操作全部撤销，使数据库恢复到故障发生之前的状态。
>
> REDO操作是指重做事务的操作，即重新执行已经提交的事务的操作，以恢复数据的一致性。

**数据的规范化**

第一范式1NF：如果关系模式R的每个关系r的属性值都是不可分的原子值，那么称R是符合第一范式的模式，r是规范化的关系。关系数据库研究的都是规范化的关系。

第二范式2NF：如果关系R是1NF，且每个非主键属性完全依赖于候选键，那么称R是符合第二范式的模式。

第三范式3NF：如果关系R是1NF，且每个非主属性都不传递依赖于R的候选键，那么称R是3NF。

BC范式BCNF ：如果关系R是1NF，且每个属性都不传递依赖于R的候选键，那么R是BCNF。

​	严格的关系范式可以看作是数据库设计中的一种解耦合技术。通过将数据分解为多个关系模式，每个模式都关注特定的数据实体或关系，从而实现了数据的解耦合和模块化。这种解耦合有助于提高数据库的灵活性和可维护性，同时也降低了数据冗余和不一致性的风险。

> 但是在实践中，常常没有严格的关系范式约束，这是因为：
>
> - 性能需求：在某些高性能的应用中，经常会牺牲规范化设计进行冗余存储，从而减少JOIN操作，加快数据的访问查询。
> - 简化开发：在一些小型应用或快速原型开发中，为了简化开发过程经常会使用非规划化的设计，简化查询和数据处理的逻辑。
> - 维护成本：在一些复杂的业务场景中，需要存储的数据具有极高的不确定性和灵活性，此时使用非规范化的设计进行数据的冗余，可以方便业务拓展。

**事务管理**

事务是用户根据业务逻辑定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。提交事务称之为COMMIT，事务回滚称之为ROLL BACK

事务有四大特性：

- Atomicity原子性：事务是数据库的逻辑工作单元，要么都做，要么都不做
- Consistency一致性：事务的执行会使数据仓库从一个一致性状态变成另一个一致性状态
- Isolation隔离型：一个事务的执行不能被其他事务干扰，即事务执行结果与其他事务执行无关
- Durability持久性：一旦一个事务被提交了，它对数据库的改变是永久的，即使系统出现故障。

**数据库设计**

四大步骤：

1. 需求背景分析：充分理解业务需求和使用场景，规划出业务实体。
2. 概念结构设计：绘制ER图，制定实体间关联的方式，并细化实体的属性。
3. 逻辑结构设计：形成多张数据表，设计每张表所需的字段、约束和数据类型。
4. 物理结构设计：数据库选型，以及索引机制、分库机制、分表机制的制定。

> 这些步骤是相互关联的，需要循序渐进地甚至反复地进行。想确保设计出的数据库能够满足实际需求，并且易于维护和扩展，需要实践经验和思考。

**分布式数据库**

​	是一种物理上独立分散，逻辑上集中管理的数据库管理系统。数据库中的每个节点有着自己的存储和计算资源，而他们又可以通过网络通信互联，共同对外提供数据存储和管理服务。通常被用在海量数据处理、高并发访问、复杂查询的场景。

> 这些年，分布式数据库层出不穷，即使是最基础的Mysql也借助中间件实现了分布式。大量的数据库让我尝尝陷入了选择困难症，在日夜思考后，我发现只要把握住一点即可：数据库是为数据服务，再炫酷的特性如果用不上也是白搭，例如：
>
> OceanBase和TiDB：依旧是关系型数据库，但是他们强调了强数据一致性和事务，对于金融服务行业有着极大的支持，并且相比Orcale，他们具有更好的开源生态和表现性能。其中Oceanbase还拥有着极强的自扩展能力
>
> PolarDB和RDS：他们都是阿里的关系型数据库，polarDB的云原生带来了更强的弹性，从硬件往上，端到端的优化带来了更好的性能。RDS则是分库分表中间件的典型代表。如何理解他们，有一个形象的比喻：DRDS和PolarDB-X的关系相当于宝马3系和5系，他们将长期共存，为不同需求的用户提供服务。
>
> Lindorm和ADB：他们都是管理数据仓库的好手，但是他们关注的则是存储和计算两个角度。Lindorm专注于海量数据存储，对于行为日志，消息、订单、物联网数据等场景有着特别的优势。ADB则更侧重于实时计算，对于实时报表、实时决策分析有着更好的支持。



**OLTP和OLAP**

OLTP即联机事务处理，是关系数据库的基础。OLAP则是联机分析处理，是数据仓库的核心部分。二者的对比如下表所示

| 对比点   | OLTP                     | OLAP                   |
| -------- | ------------------------ | ---------------------- |
| 操作主体 | 开发人员、底层管理人员   | 分析人员、高级管理人员 |
| 功能责任 | 日常操作处理，简单的事务 | 统计决策，复杂的查询   |
| DB设计   | 面向应用的               | 面向主题的             |
| 数据记录 | 当前的、低维的、分立的   | 历史的、高维的、聚集的 |
| 响应时间 | 毫秒级、秒级             | 秒级～小时级都有       |
| 存取大小 | GB级别、读写数十条记录   | TB级别、读上万条记录   |

> ​	在实际的数据库领域中，OLTP和OLAP并不是完全割裂的，OLTP有时也会有海量数据如交易系统，OLAP上也会有应用需求如实时报表。OLAP本质上是OLTP的自然延伸，在数据量爆发式增长的今天，有的数据库演变成了数据仓库，而OLAP正是支持我们去挖掘其中数据价值的行业利器。

#### 2.3 计算机网络

**OSI七层架构**

| 层次名称   | 主要功能                                                     | IM场景举例                                             |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| 物理层     | 负责传输比特流，管理网络电缆、光纤、无线信号等传输媒介，将数据从物理媒体上发送和接收，涉及到一系列机械、电气特性。 | 确保数据的物理传输。                                   |
| 数据链路层 | 在相邻节点（局域网）之间可靠地传输数据帧。它提供了错误检测和纠正、帧同步、流量控制等功能，服务访问点为物理地址。 | 确保数据在网络实体之间的可靠传输                       |
| 网络层     | 负责在网络中传输数据包，提供寻址和路由功能、解决网络拥塞，异构网络互联等问题，使得数据能够在不同网络间进行传输。服务访问点为网络IP | 将数据包从源网络节点路由到目标网络节点。               |
| 传输层     | 负责在网络中的两个节点之间建立可靠的数据传输连接，并提供端到端的数据传输服务。TCP保证数据包无差错，按顺序，无丢失和冗余的传输。服务访问点为端口号 | 传输层负责将IM消息切分成数据段并进行可靠的传输         |
| 会话层     | 负责建立、管理和终止会话（通信会话）的连接，提供会话控制和同步以及数据检查，安全验证等功能 | 建立和管理IM聊天会话                                   |
| 表示层     | 负责数据的表示，根据服务规则对数据进行解析和转换。包括处理数据结构的转换、加解密、编解码等操作 | 处理消息协议的解析转换和加解密操作                     |
| 应用层     | 负责为终端用户提供特定应用程序的服务接口，并与用户进行交互。 | 实现IM聊天应用程序，提供用户界面和消息读取发送等功能。 |

需要注意的是，不同应用场景可能涉及到更多的网络协议和技术，不仅仅局限于OSI模型中的七层。但是，OSI模型提供了一种通用的框架，用于理解和描述不同层次之间的功能和相互关系。

**网络分类与组网接入技术**

根据网络覆盖的地理范围：局域网、城域网、广域网

根据网络拓扑结构：总线型、星型、树型、环型、网状

根据数据传输介质：同轴电缆、铜线、光纤、无线接入

根据传输控制技术：以太网、令牌网、FDDI网、ATM网、帧中继网、ISDN网

**网络服务器与网络存储**

​	网络服务器与个人计算机在多用户多任务环境下的可靠性方面存在明显差异。服务器通过更强大的硬件、冗余设计、专门的操作系统和管理工具以及高级别的安全性措施，提供更高的可靠性、性能和故障容忍性，以满足大规模并发访问和处理的需求。

- DAS 是直接将存储设备连接到主机的存储技术，适用于单个主机或服务器。
- NAS 是通过网络连接的存储设备，适用于文件级别的共享存储和协作工作环境。
- SAN 是将存储设备构建成了网络，适用于块级别的高性能存储访问，具有高可用性和可扩展性，适用于企业级应用和数据库。

**网络安全**

防火墙无法阻止和检测基于数据内容的漏洞攻击和病毒入侵，因为它主要对基于网络的攻击行为进行拦截。

扫描器无法对正在入侵网络的攻击进行检测，攻击者甚至可以使用扫描器来探测目标系统的漏洞，进而发起攻击。

入侵防御可以对实时的网络入侵进行检测，还可以识别恶意行为，并且主动做出阻断攻击、触发报警等操作。

除了技术上的管控，定时更新或加强防控策略、对敏感数据进行加密、安全意识培训也同样重要。





#### 2.4 多媒体技术

**媒体、多媒体、多媒体技术概念**

媒体是承载信息的载体，多媒体则是包括数字、文字、语音、图像、动画等各种媒体

多媒体技术是以数字化（计算机、通信、广播电视）为基础，能够对多媒体信息进行采集、编码、存储、传输、处理和表现，并使之建立起有机的逻辑联系，集成为一个系统并且有良好的交互性的技术。多媒体的显著特征有四点：

- 多样性
- 集成性
- 交互性
- 实时性

MPC：multimedia personal computer = PC + CD-ROM+声卡+显卡+多媒体操作系统。这是一种具备多媒体功能的个人电脑系统。它结合了计算机硬件和软件组件，旨在支持多媒体内容的创建、编辑、播放和交互。

**多媒体压缩编码标准**

MPEG（Moving Picture Experts Group）和JPEG（Joint Photographic Experts Group）是两**组**常用的图像和视频压缩标准，用于减少数据的存储空间和传输带宽需求，同时保持可接受的视觉质量。

无论是MPEG还是JPEG，它们的压缩算法和参数设置都可以影响压缩效果和最终图像质量。在实际应用中，根据具体需求和使用场景，可以选择适当的压缩标准和参数设置，以平衡文件大小、传输带宽和视觉质量之间的需求。

#### 2.5 系统性能

**延迟、延迟抖动、丢包率对吞吐量的影响**

网络延迟越大，吞吐量可能会减少。这是因为延迟的增加会导致数据包在网络中的传输时间延长，从而降低了数据传输速率和吞吐量。

延迟抖动和吞吐量之间没有直接的定量关系。然而，当网络中存在高延迟抖动时，数据包的到达时间会更不可预测，可能导致数据传输不连贯、质量下降，从而影响吞吐量。

当丢包率增加时，吞吐量会受到影响，因为数据包需要进行重传，从而减少了有效的传输数据量。因此，丢包率较高的网络通常具有较低的吞吐量。

**吞吐量和服务质量的联系**

吞吐量是网络设备或者网络系统的性能指标，而服务质量则是网络的应用类性能指标。二者不在一个维度上，但通常吞吐量越大的网络系统，其上层的应用服务质量也越高。除此之外，

网络的系统/设备类评价指标还有：延迟、丢包率、速率、可达性、信道利用率等

网络的应用类评价指标还有：安全保密性、网络络对语言应用的支持程度、网络对视频应用的支持程度等。

**操作系统和数据库等性能指标也类似**

技术层面的可靠性，可达性，吞吐量，响应时间，延迟、资源利用率等，

应用上的RASIS特性：reliability、availabilty、servurity、integrity、serviceability、以及可移植性等。

**阿姆达尔定律**

加速比：1 / ((1 - P) + (P / N))

- 加速比表示并行计算相对于串行计算的性能提升倍数。
- P 表示可并行执行的部分所占的比例。
- N 表示并行计算使用的处理单元数量。

阿姆达尔定律最初是在并行计算中的概念，然而推广来看，也可以指指计算机系统中对某一部件采用某种更快的执行方式所获得的系统性能改变程度’，取决于这种方式被使用的频率或所占总执行时间 的比例。

### 三、信息系统基础知识

#### 3.1 信息化概述

**“两化”融合的含义**

信息技术和工业技术，信息设备与工业设备的融合

信息资源与材料、能源等工业资源的融合

虚拟经济和工业实体经济的融合

信息化与工业化发展战略的融合

**《国家信息化发展战略纲要》**

| 战略要求 | 时间要求  | 解释                                                         |
| -------- | --------- | ------------------------------------------------------------ |
| 第一步   | 2017-2020 | 围绕...服务重大战略布局。促使信息化成为趋势现代化建设的先导力量，网信事业上先行一步。 |
| 第二步   | 2020-2025 | 紧紧围绕建设网络强国目标，实现技术现行，应用领先，产业发达，网络安全坚不可摧。 |
| 第三步   | 2025-2050 | 信息化全面支撑建设富强...社会主义现代化国家建设，网络强国巩固，引领全球信息化发展。 |

#### 3.2 信息系统工程总体规划

**信息系统的集成**

信息系统：

信息系统的集成：



**信息系统规划方法**

关键成功因素法（Critical Success Factors，CSF）：CSF方法是一种基于关键成功因素的规划方法。这种方法强调在规划过程中关注那些对组织战略目标和业务成功至关重要的因素，从而确保信息系统能够使得组织的项目不断取得里程碑式的成功。

企业系统规划法（Business System Planning，BSP）：BSP方法是一种将企业业务需求和信息技术相结合的规划方法。BSP方法强调信息系统与企业的业务需求紧密结合，确保信息系统能够满足企业的整体规划和发展要求。

战略目标集转化法（Strategic Goal Set Transformation，SST）：SST方法是一种以战略目标为导向的规划方法。它通过将组织的战略目标转化为信息系统的具体目标和要求，为信息系统的总体规划提供指导。确保信息系统能够支持和实现组织的战略目标。



**信息化需求的三个层次**

战略需求：为了提升组织的竞争能力、为组织的可持续发展提供一个信息化的支持环境的需要

运作需求：实现组织信息化战略目标的需要、运作策略的需要，人才培养的需要

技术需求：考虑到信息系统开发时间和难度，在信息技术层面上对系统的搭建、完善、升级、整合的需要



#### 3.3 信息化的典型应用

**电子政务**

G2G、G2E、G2B、G2C

**电子商务保障体系**

电子商务是指利用信息化手段在网络上买卖产品或提供服务，广义而言还包括企业内部以及企业间的商务活动。 甚至是用户之间的。

B2B、B2C、C2C都离不开电子商务的保障体系：法标安信在现技运服

法律法规体系、标准规范体系、安全认证体系、信用体系

在线支付体系、现代物流体系、技术装备体系、运行监控体系、服务体系

电子商务发展的基本原则：

企业主体、政府推动

虚实结合、统筹兼顾

着力创新、注重时效

规范发展、保障安全



**企业信息化**

**企业资源计划ERP**

Enterprise resource 



**客户关系管理CRM**

customer relationship management的核心是客户。在以客户为中心的基础上，利用信息化手段重构市场营销和业务活动等业务流程。不仅如此，CRM还要保证前台应用系统能够提升用户的满意度、忠诚度，从而达到企业最终获利的目的。

**供应链管理SCM**

Supply chain management的核心是供应链，利用信息化技术对企业供应链中的物质流、信息流、资金流、商流进行全面规划和赋能，进行一系列的计划组织、协调管控、数据追踪。供应链管理包括六大功能：需求管理、供应链计划、生产计划、调度计划、运输计划，配送计划。

**企业门户**

企业信息门户EIP：为人们提供企业信息, 它强调对结构化与非结构化数据的收集、访问、管理和无缝集成。这类门户必须提供数据查询、分 析、报告等基本功能’企业员工、合作伙伴、客户、供应商都可以通过企业信息门户非常方便地获 取自己所需的信息。

企业知识门户EKP：帮助企业员工获取工作内容、完成工作所需要的知识、与其他员工取得联系或快速链接到其他门户等。企业知识门户的使用对象是企业员工’它的建 立和使用可以大大提高企业范围内的知识共享’并由此提高企业员工的工作效率。

企业应用门户EAP：实际上是对企业业务流程的集成。 它以商业流程和企业应用为核心’把商业流程中功能不同的应用模块通过门户技术集成在一起。便于用户或合作伙伴访问相应的业务系统，从而完成使用或交易。

### 四、系统开发基础知识

#### 4.1 软件开发方法

**敏捷方法**

- 强调适应性而非预设行
- 强调面向人的而非面向过程的

价值观：及时的沟通与反馈、设计的简单和高效

**RUP**

rational unified process 统一软件开发过程：一种迭代式、增量式的软件开发过程，强调在软件开发过程中的灵活性、可重复性和可管理性。它提供了一系列的指导原则、阶段、工作流程、文档模板和角色定义，以帮助开发团队有效地建模、规划、设计、实施和测试软件系统。RUP的核心概念包括以下几个方面：

- 迭代开发：RUP将软件开发过程划分为一系列的迭代，每个迭代都包含需求分析、设计、编码、测试和部署等阶段。每个迭代都会产生一个可工作的软件版本，可以逐步完善和改进。

- 架构驱动：RUP强调软件架构的重要性，将架构设计作为开发过程的关键驱动因素，确保系统的可靠性、可扩展性和可维护性。

- 风险管理：RUP通过风险管理的方法，识别和管理项目中的风险，以减少项目失败的可能性。它鼓励在早期迭代中解决高风险的问题，提高项目的成功率。

- 过程定制：RUP的过程是可定制的，可以根据具体项目的需求和特点进行调整和适应。开发团队可以选择和配置适合自己项目的过程流程、文档模板和工具。

**软件开发工具**

软件开发工具: 需求分析工具、设计工具、编码与排错工具

软件维护工具: 版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具	

软件管理和软件支持工具:项目管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择  

**软件设计方法**

面向对象的设计：架构图、领域模型图、对象交互图

面向过程的设计：业务时序图，用例流程图

上述二者在设计文档中往往是同时存在的，尤其是大型项目。除此之外也包含基础软件设施的设计和用户交互界面的设计

#### 4.2 需求管理

**需求管理的原则**

1、在需求项目确立并批准后，为软件需求建立基线

2、产品规划、活动策划、软件需求三者在基线上需要保持同步

**需求管理的信息控制**

版本控制信息需要包括：变更内容、变更日期、涉及的人员以及变更的原因

需求属性需要包括：需求名称、创建时间、创建&审批人、原因和依据、产品版本号、需求优先级、验收的标准

**需求变更**

为了严格控制软件的变更，需求的变更有如下原则：

- 对变更的决策进行评估、将负面影响控制到最低。
- 对涉及的人选进行评估、考量变更的实现成本。
- 要保留原来的资料，遵循需求创建的流程规范。
- 获得具体批准，并通知所有相关的人

**需求跟踪**

traceablity link如下

客户需求----->软件需求----->下一级需求----->下一阶段客户需求

**需求变更的代价和风险。**

 (1)变更只能在项目时间、预算、资源等的限制允许范围内进行协商

 (2)进行影响分析的能力依赖于跟踪能力、数据的质量和完整性。

#### 4.3 软件开发管理

**软件项目三要素**

项目范围：

时间周期：

成本预算：

**配置与文档的管理**

由于视角不同，配置和文档都会分为两种，他们分别面向不同的对象，也需要分开来管理

- 系统文档配置：与系统实现相关的，控制系统内部行为的内容等 
- 用户文档配置：与用户使用和理解相关的，控制用户使用特性的内容等。

实际上，文档、程序代码、网站、数据等都可以称之为配置，是产品在生命周期的各个阶段产生的各种要素的集合。

**后期的逆向与重构**

逆向：通过分析已有的程序，寻求比源代码更高级的抽象形式（文档、图）的活动，是在不同抽象层级中进行的溯源行为。

重构：分析并修改已有的程序，寻求比原来的实现更为高效合理的方式的活动，是在同一抽象层级中进行的溯源行为。

对于一套系统程序的重构往往都是先从逆向开始的，即先抽象出来，再用更合理更强大更高效的方式具象回去，形成新的版本。

逆向工程抽象出来的设计叫做恢复设计，对逆向后的系统进行修改、升级被称为重构，得出的新版本叫重构工程。



**逆向工程恢复的级别**

实现级别：包含语法树、数据结构、符号公式等

结构级别：程序之间的关系，如流程图

功能级别：程序组成的服务之间的关系，如交互图

领域级别：实体在应用领域之间的关系，如架构图

抽象程度越高的级别，恢复起来越困难，对工具的依赖越少，人的主观成分就越多

**软件重用**

重用的目的是为了降低工作量、提高工作效率，缩短开发周期，甚至提高软件的质量和规范化程度

重用的不管可以是程序代码，还包括需求文档，技术文档，设计方案以及测试用例等

软件重用可以分为横向和纵向，以支撑不同维度的业务系统。



## 第二篇、架构设计高级知识

### 五、**软件架构**设计

#### 5.1 软件架构概念

软件架构SA是系统在设计和构建时采用的整体结构和组织方式，它定义了软件系统中各个组成部分之间的关系，交互方式以及功能分配，以及系统在不同抽象层次的组织结构。软件架构的设计对于软件的系统的可维护性，可扩展性，可重用性和性能有着重要影响。是降低成本、改进质量、按时和按需交付产品的关键因素。

软件架构的生命周期包括：架构设计阶段、功能实现阶段、构件组装阶段、系统部署阶段、后开发阶段。每个阶段的功能的作用和意义都不同。除此之外，还有需求分析阶段作为开端，在此阶段会进行功能和分工的确定，让所有阶段的参与者共同交流。实际上，真正的开始其实是架构设计阶段，这个软件架构被探讨和关注最多的阶段。

**软件架构的描述**

ADL是软件体系结构的描述语言，其不光关注软件模块的描述，更关注构件之间的互联机制（连接子）。

在描述时还有多识图方法，是用来描述软件体系结构不同方面的，体现了关注点分散的思想，常与ADL一同使用描述软件体系结构

常见的组合是UML --4+1view模型，实际上视图不局限于设计阶段，很可能贯穿整个软件架构的生命周期。



#### 5.2 基于架构的开发方法

**基于软件体系结构的设计**

从项目总体功能框架明确开始，ABSD是一个自顶向下，拆分模块，迭代细化的过程。而每一步都有清晰的定义，这有助于降低软件体系结构的不确定性和随意性，也便于后续的实现。ABSD是软件架构设计中最核心的方法论。

ABSD模型将软件体系结构设计分为体系结构需求、设计、文档化、复审、实现和演化六个子过程：

体系结构需求：

- 获取用户需求：系统的商业目标、功能目标、质量目标
- 标识拟用构件：生成领域模型图——>填充类属性——>分组打包

体系结构设计：

- 设计：体系架构图——>构件交互图——>实现的映射
- 评审：必须邀请本次开发之外的人进行评审

体系结构文档化：

- 输出体系结构规格说明和测试体系结构需求的质量设计说明书

体系结构实现：

- 以产出的结构说明书为基础，对构件进行实现和组装，集成测试，上线部署。

体系结构复审：

- 在软件的新版本上线后，邀请用户或领域专家进行基于线上表现再次审查，尽早发现潜在的风险缺陷以及功能和架构的优化点

体系结构演化

- 在复审过后，对软件系统进行迭代更新，这可能涉及到构件本身和之间交互方式的变化，甚至是流程或架构的变化，这需要再次进行设计和文档化和评审，并且按照一定的计划实施。

#### 5.3 软件体系结构的风格

**经典软件体系架构**

软件体系结构的核心目标就俩字：复用，为了完成复用以及在其基础上实现更好的扩展性，可维护性，产生了多种经典的结构风格：

1. 分层架构（Layered Architecture）：将系统划分为若干层，每一层都提供一组相关的功能。每一层只与其上一层和下一层进行通信，提高了系统的可维护性和灵活性。
2. 客户端-服务器架构（Client-Server Architecture）：将系统划分为客户端和服务器两个部分。客户端发送请求并接收响应，服务器处理请求并返回响应。这种架构可实现分布式计算和资源共享。
3. MVC 架构（Model-View-Controller Architecture）：将系统划分为模型（Model）、视图（View）和控制器（Controller）三个部分。模型处理数据和业务逻辑，视图负责用户界面展示，控制器协调模型和视图之间的交互。
4. 事件驱动架构（Event-Driven Architecture）：系统中的组件通过事件的产生和响应进行通信。当一个事件发生时，相关的组件会接收到事件并执行相应的操作。
5. 面向服务架构（Service-Oriented Architecture，SOA）：将系统划分为一组可重用的服务，这些服务以服务接口的形式对外提供功能。各个服务之间通过标准化的协议进行通信。
6. 微服务架构（Microservices Architecture）：将系统拆分为一组小型、独立的服务，每个服务都可独立部署和扩展。每个服务负责特定的业务功能，通过轻量级通信机制进行交互。

**特定领域软件体系结构**

DSSA指的是在某一个领域内为一组应用提供参考和规范的标准软件体系结构，即某一特定领域内标准软构件的集合。基本活动包括：

- 领域分析：通过分析领域中的共性需求，建立领域模型

- 领域设计：设计可以适应领域需求变化的DSSA

- 领域实现：搜集、获取、产生、积累一些可重用的模型与信息



### 六、UML建模和XML技术

#### 6.1 UML基础概念和开发过程

**UML图的分类**

UML的四种类型图特点及对应的视图。

- 用例图:从外部用户角度描述系统功能,并指出功能执行者

  - 用例图：展现了—组用例、参与者及其之间的关系。

  <img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230716224914640.png" alt="image-20230716224914640" style="zoom:30%;" />

- 静态图:显示了系统的静态结构’特别是存在事物的种类的内部结构相互之间的关系，首先研究分析问题领域确定系统需求;然后确定类,明确类的含义和指责确定属性和操作; 最后确定类之间的关系。包括：

  - 类图：分为泛化、实现、聚合、组合、关联、依赖

  - 对象图：是类图在运行时的一个实例，类图在系统的整个生命周期都是有效的’对象图只在系统的某_时间段存在

    <img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230716224338813.png" alt="image-20230716224338813" style="zoom:30%;" />

  - 组合结构图：描述了一个"组合体"的内部组成，以及他们之间的关系。

  <img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230716225700780.png" alt="image-20230716225700780" style="zoom:30%;" />

  - 包图：系统的分解结构,表示包和包之间的关系,展现系统模块之间的依赖关系

    <img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230716224704124.png" alt="image-20230716224704124" style="zoom:30%;" />

- 行为图:描述系统的动态模型和组成对象间的交互关系包括：

  - 活动图

  <img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230716225125658.png" alt="image-20230716225125658" style="zoom:30%;" />

  - 交互图

    <img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230716224807226.png" alt="image-20230716224807226" style="zoom:30%;" />

  

  - 状态图

  <img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230716224843466.png" alt="image-20230716224843466" style="zoom:30%;" />

  

  - 顺序图，时序图

  <img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230716225251447.png" alt="image-20230716225251447" style="zoom:30%;" />

  - 通讯图

  <img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230716225432129.png" alt="image-20230716225432129" style="zoom:30%;" />



- 实现图:描述软件实现系统的组成和分布状况包括：

  - 构件图

    <img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230716224026219.png" alt="image-20230716224026219" style="zoom:30%;" />

  - 部署图

    <img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230716224218677.png" alt="image-20230716224218677" style="zoom:30%;" />

**使用UML的开发过程**

1. 从业务需求描述出发，获取执行者和执行场景，对场景进行汇总、分类、抽象形成用例确定执行者与用例、用例与用例之间的关系生成用例图。
2. 从用例图中提取边界类、实体类和控制类，形成类图。根据类的职责以及他们之间的关系，构建出行为交互图。
3. 在上述两个步骤互相迭代之后，系统架构已基本成型，此时可以产出包图、部署图、架构图等其他信息

**分析与设计模型**

面向对象的分析模型主要由顶层架构图、用例与用例图和领域模型图构成:

设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的 状态和用以描述流程化处理过程的活动图等。

结构化分析模型一般采用E-R表示数据模型、DFD表示功能模型、用状态图表示行为模型



#### 6.2 XML技术

**XML可扩展标记语言**

可扩展标记语言（Extensible Markup Language，简称 XML）是一种用于描述和传输数据的标记语言。它被设计为具有自我描述性和可扩展性，使数据能够在不同的系统和应用程序之间进行交互和共享，即可用XML为某一专业领域开发一种标记性语言，创建完这种语言之后就可以使用XML来标记该领域的结构化文档了。

XML 的主要特点包括：

1. 可扩展性：XML 允许用户定义自己的标记，创建适合特定领域的数据结构。通过定义和使用自定义的标记，可以为数据添加语义信息，以便更好地描述数据的含义和关系。

2. 平台无关性：XML 是一种独立于平台和应用程序的数据格式，它可以在不同的操作系统、编程语言和应用程序之间进行交互和共享。这种平台无关性使得数据能够在异构环境中进行传输和处理。

3. 可读性：XML 使用纯文本形式表示数据，标签和数据之间使用可见的字符进行分隔，使得 XML 数据易于阅读和理解。同时，XML 支持注释和格式化，可以提高数据的可读性和可维护性。

4. 支持结构化数据：XML 支持以层次结构方式组织数据，通过嵌套和组合标记，可以表示复杂的数据结构和关系。这使得 XML 适用于表示文档、配置文件、数据交换等各种应用场景。



**DTD类型定义文档**

DTD（Document Type Definition）是一种用于定义 XML（eXtensible Markup Language）文档结构和元素约束的语法规范。它描述了 XML 文档中可以使用的元素、元素的顺序、元素的属性以及它们之间的关系。DTD 可以用来验证 XML 文档的结构是否符合规范，确保文档的有效性。

DTD 定义了以下几个方面的内容：

1. 元素（Elements）：DTD 定义了 XML 文档中允许出现的元素及其顺序、次数，以及每个元素可以具有子元素和属性。
2. 属性（Attributes）：DTD 规定了元素可以拥有的属性及其类型。属性可以有不同的约束条件，如数据类型、默认值、唯一性等。
3. 实体（Entities）：DTD 允许定义实体，实体可以是字符实体或参数实体。字符实体用于替代文本中的特殊字符，参数实体可以在文档中引用其他实体。

引入DTD的原因（使用DTD进行验证增加了操作时间）:

- 提供一种验证的手段。
- 现了文件格式的统—化
- 提高了文件的重用性



**其他相关规范**

XSL（Extensible Stylesheet Language）可扩展样式展示语言是一种用于对 XML 文档进行样式化和转换的语言。它由两个部分组成：

1. 将XML文档转换为可浏览可输入的格式
2. 解析XML文档，形成结果树，转换为展示的具体样式。

最典型的就是XSLT了



XSLT、XPath、XLink 和 XPointer 是 XML 处理和转换中常用的技术和语言，它们共同为 XML 文档的样式化、数据转换、链接和定位提供了丰富的功能和工具。最常用的是 XSLT（XSL Transformations），用于将 XML 文档转换为不同的输出格式，如 HTML、XML 或纯文本。

- XPath 是一种用于在 XML 文档中定位和选择节点的语言。
- XPointer 是 XPath 的扩展，提供了更精确的节点定位方式，用于指定 XML 文档中的特定部分。
- XLink 是一种在XML文档中定义链接关系的语言，包括超链接和引用。
- XSLT 使用 XPath 来选择和定位 XML 文档中的节点，并通过 XSL 样式表将选定的节点转换为所需的输出格式。
- XSL-FO（XSL Formatting Objects）用于定义文档的格式化和排版。

这些技术在 XML 处理中常常结合使用，比如使用 XSLT 根据 XLink 创建的链接关系来转换文档，使用 XPointer 定位 XML 文档中的特定节点并对其进行操作。最后使用XSL-FO（XSL Formatting Objects）生成XML文档的格式化排版样式。

### 七、设计模式

#### 7.1 设计模式的原则

**设计模式的六大原则是面向对象设计中的重要指导原则**，它们是：

1. 单一职责原则（Single Responsibility Principle，SRP）：
   - 一个类应该只有一个引起变化的原因。换句话说，一个类应该只有一个职责。
   - 这个原则强调将一个类的功能限制在一个单一的领域内，避免一个类承担过多的责任，提高类的内聚性和可维护性。

2. 里氏代换原则（Liskov Substitution Principle，LSP）：
   - 子类对象应该能够替换父类对象而不影响程序的正确性。
   - 这个原则要求子类必须能够完全替代父类，且在替代过程中不改变程序的正确性。它保证了继承关系的正确性和稳定性。

3. 依赖倒置原则（Dependency Inversion Principle，DIP）：
   - 高层模块不应该依赖于低层模块，两者都应该依赖于抽象层。
   - 这个原则强调模块之间的解耦，通过引入抽象接口或抽象类作为中间层，实现高层模块和低层模块之间的解耦，提高系统的灵活性和可扩展性。

4. 接口隔离原则（Interface Segregation Principle，ISP）：
   - 不应该强迫客户端依赖它们不使用的接口。
   - 这个原则提倡将接口细化，根据客户端的实际需求划分更小粒度的接口，避免客户端依赖不需要的接口，减少接口的冗余和不必要的依赖。

5. 迪米特原则（Law of Demeter，LoD）：
   - 一个对象应该对其他对象有尽可能少的了解，即最小知识原则。
   - 这个原则强调对象之间应该保持松耦合，尽量降低对象之间的依赖关系，避免直接访问其他对象的内部细节，提高系统的模块化和可维护性。

6. 开闭原则（Open-Closed Principle，OCP）：
   - 软件实体应该对扩展开放，对修改关闭。
   - 这个原则强调在设计中要尽量避免修改现有的代码，通过抽象、接口和多态等手段实现系统的可扩展性和可维护性。

这些原则提供了面向对象设计的指导原则，帮助开发者设计出灵活、可扩展和可维护的软件系统。它们通常在设计模式的实践中得以应用，并相互关联以提供更好的设计解决方案。

#### 7.2  创建型设计模式

创建型设计模式是一类设计模式，它们关注对象的创建过程，提供了创建对象的灵活性和可扩展性。下面是几种常见的创建型设计模式：

1. 工厂模式（Factory Pattern）：
   - 工厂模式通过一个工厂类来创建对象，将对象的实例化过程封装起来，客户端只需通过工厂类来获取所需对象的实例。
   - 工厂模式可以根据不同的条件创建不同的对象，隐藏了对象创建的细节，提供了一种统一的对象创建接口。

2. 抽象工厂模式（Abstract Factory Pattern）：
   - 抽象工厂模式提供一个接口来创建一系列相关或相互依赖的对象，而无需指定具体的类。
   - 抽象工厂围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂，实现了一族产品的创建。

3. 单例模式（Singleton Pattern）：
   - 单例模式保证一个类只有一个实例，并提供一个全局的访问点。
   - 单例模式通常适用于需要共享资源或控制资源访问的情况，确保对象的唯一性和一致性。

4. 原型模式（Prototype Pattern）：
   - 原型模式通过复制已有对象的原型来创建新的对象，避免了直接创建对象的开销。
   - 原型模式允许在运行时动态创建对象，使得对象的创建过程更加灵活，同时保持了对象的一致性。

5. 建造者模式（Builder Pattern）：
   - 建造者模式将一个复杂对象的构建过程与其表示分离，通过一步步地构建对象来创建最终的复杂对象。
   - 建造者模式可以灵活地组装和构建对象，隐藏了对象的内部细节，客户端只需关注对象的组装过程。

这些创建型设计模式都有不同的应用场景和优缺点，可以根据具体的需求选择适合的模式来创建对象。它们提供了灵活性、可扩展性和可维护性，帮助开发者更好地管理对象的创建过程。

#### 7.3  结构型设计模式

结构型设计模式是一类设计模式，它们关注对象和类之间的组合，以及构建更大结构的方式。这些模式提供了不同的方式来实现对象之间的关系，以解决系统的结构和组织问题。以下是几种常见的结构型设计模式：

1. 适配器模式（Adapter Pattern）：
   - 适配器模式用于将一个类的接口转换为客户端所期望的另一个接口。
   - 适配器模式使得原本由于接口不兼容而无法一起工作的类能够协同工作，增加了类的复用性和灵活性。

2. 桥接模式（Bridge Pattern）：
   - 桥接模式将抽象和实现分离，使得它们可以独立地变化。
   - 桥接模式通过将继承关系转化为关联关系，减少了抽象和具体实现之间的耦合，提高了系统的灵活性和可扩展性。

3. 组合模式（Composite Pattern）：
   - 组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。
   - 组合模式使得用户对单个对象和组合对象的使用具有一致性，简化了对树形结构的操作。

4. 装饰器模式（Decorator Pattern）：
   - 装饰器模式动态地给一个对象添加额外的功能，而无需修改原始对象的结构。
   - 装饰器模式通过包装原始对象，逐层添加功能，实现了对对象功能的灵活扩展。

5. 外观模式（Facade Pattern）：
   - 外观模式提供了一个统一的接口，用于访问子系统中的一组接口。
   - 外观模式隐藏了子系统的复杂性，为客户端提供了一个简化的接口，降低了客户端与子系统的耦合度。

6. 享元模式（Flyweight Pattern）：
   - 享元模式通过共享对象来最小化内存使用，提高系统的性能。
   - 享元模式通过将对象的状态分为内部状态和外部状态，共享内部状态来实现对象的复用。
7. 代理模式（Proxy Pattern）：
   - 代理模式其他对象提供一种代理以控制对这个对象的访问。
   - 代理模式中通过创建具有现有对象的对象，以便向外界提供功能接口。

这些结构型设计模式都有不同的应用场景和特点，可以根据具体的需求选择适合的模式来解决结构组织和对象关系的问题。它们提供了灵活性、可扩展性和可维护性，帮助开发者更好地组织和管理系统的结构。

#### 7.4 行为型设计模式

行为型设计模式是一类设计模式，它们关注对象之间的通信和交互，以及如何有效地组织和管理对象的行为。这些模式提供了在对象之间进行通信、协作和控制的方式，以实现系统的灵活性和可扩展性。以下是几种常见的行为型设计模式：

1. 观察者模式（Observer Pattern）：
   - 观察者模式定义了一种一对多的依赖关系，当一个对象的状态发生变化时，其依赖者将自动收到通知并进行更新。
   - 观察者模式实现了对象之间的松耦合，使得一个对象的改变可以影响到其他对象，实现了对象之间的发布-订阅机制。

2. 策略模式（Strategy Pattern）：
   - 策略模式定义了一系列的算法，并将每个算法封装成独立的对象，使得它们可以互相替换。
   - 策略模式使得算法的选择和使用与客户端分离，客户端可以在运行时动态地选择所需的算法，实现了算法的可变和可扩展。

3. 迭代器模式（Iterator Pattern）：
   - 迭代器模式提供了一种顺序访问聚合对象元素的方式，而不需要暴露聚合对象的内部表示。
   - 迭代器模式将遍历和具体集合分离，使得客户端可以独立地访问聚合对象的元素，同时隐藏了集合的内部结构。

4. 命令模式（Command Pattern）：
   - 命令模式将请求封装成一个对象，使得请求的发送者和接收者解耦。
   - 命令模式允许请求的参数化和操作的延迟执行，可以实现请求的排队、撤销和重做等功能。

5. 状态模式（State Pattern）：
   - 状态模式允许对象在内部状态改变时改变其行为，使得对象看起来好像修改了其类。
   - 状态模式将对象的行为封装在不同的状态对象中，并通过切换状态对象来改变对象的行为。

6. 责任链模式（Chain of Responsibility Pattern）：
   - 责任链模式将请求的发送者和接收者解耦，并通过一条处理链来处理请求。
   - 责任链模式允许多个对象都有机会处理请求，直到其中一个对象处理成功或处理链结束。
7. 模板方法模式（Template Method Pattern）：
   - 模板方法模式定义了一个算法的骨架，将具体步骤的实现延迟到子类。
   - 模板方法模式允许子类在不改变算法结构的情况下重新定义算法中的某些步骤，以实现算法的个性化定制。
8. 访问者模式（Visitor Pattern）：
   - 访问者模式将算法的操作从元素的类中分离出来，使得可以在不修改元素类的情况下增加新的操作。
   - 访问者模式适用于对元素结构进行操作的场景，通过访问者对象访问元素对象，实现了元素对象和操作的解耦。
9. 解释器模式（Interpreter Pattern）：
   - 解释器模式定义了一个语言的文法表示，并提供了解释器来解释该语言中的句子。
   - 解释器模式将一个语言的句子表示为抽象语法树，并提供了解释器来执行特定的语法规则，实现了对语言的解释和执行。
10. 备忘录模式（Memento Pattern）：
    - 备忘录模式用于在不破坏封装性的前提下保存和恢复对象的内部状态。
    - 备忘录模式通过创建备忘录对象来保存对象的状态，并可以在需要时将对象恢复到先前的状态，实现了对象状态的保存和回滚。
11. 中介者模式（Mediator Pattern）：
    - 中介者模式定义了一个中介者对象，用于封装一组对象之间的交互，使得对象之间的耦合松散。
    - 中介者模式将对象之间的交互逻辑集中在中介者对象中，使得各个对象之间通过中介者进行通信和协作

这些行为型设计模式提供了不同的方式来组织和管理对象的行为，以满足不同的交互和控制需求。开发者可以根据具体的需求选择适合的模式来实现系统的灵活性、可扩展性和可维护性。

### 八、面向构件的软件设计

#### 8.1 软件构件概念

**软件构件（Software Component）**

是指可独立使用和替换的软件模块，它具有清晰的接口和明确定义的功能。软件构件是软件系统的组成部分，通过组合和交互以实现整个系统的功能。软件构件具有以下特点：

1. 可独立性：构件是可独立使用的单元，可以被其他部分或系统调用和使用，而无需了解其内部实现细节。

2. 易替换性：构件可以被其他具有相同接口的构件替换，从而实现灵活性和可维护性。

3. 接口定义：每个构件都有清晰的接口定义，明确了构件与其他构件之间的交互方式，包括输入和输出。

4. 可重用性：构件的设计和实现应该具有高度的可重用性，以便在不同的系统中进行复用，提高开发效率和软件质量。

软件构件的设计和开发过程可以采用不同的技术和方法，例如面向对象编程（OOP）和服务导向架构（SOA）。构件化的方法可以帮助软件开发团队更好地组织和管理代码，并促进模块化和可维护性。



**构件的布线标准**

构件的布线标准通常指的是构件之间的交互和通信方式的规范，常见的如：

1. 定义接口型
2. RPC远程过程同步调用
3. Message Queue异步通信
4. Web、GateWay通信规范

具体使用哪种布线标准取决于具体的应用场景和技术栈选择。

在设计构件的布线标准时，需要考虑以下几个重要问题：

1. 接口定义和协议：确定构件之间的接口定义和通信协议是首要任务。这包括确定输入和输出参数、方法调用方式、数据格式等。接口定义语言（IDL）和消息格式的选择都是关键决策。

2. 通信机制：选择适当的通信机制，例如远程过程调用（RPC）、消息队列、事件驱动架构等。需要考虑构件之间的通信频率、延迟要求、可靠性需求等因素。

3. 数据传输和序列化：在构件之间传输数据时，需要确定数据的传输方式和序列化格式。选择高效的数据传输机制，避免过多的数据转换和序列化/反序列化操作。

4. 安全性和验证：确保构件之间的通信是安全的，防止未经授权的访问和数据泄露。考虑使用加密、身份验证和授权等机制来确保通信的安全性。

5. 异常处理和容错机制：设计构件布线标准时，需要考虑异常情况的处理和容错机制。例如，如何处理构件之间的通信故障或部分故障的情况。

6. 可扩展性和互操作性：布线标准应具备良好的可扩展性和互操作性，以便在需要时能够方便地添加新的构件或替换现有的构件。

7. 性能和效率：构件布线标准应考虑性能和效率因素，以便在构件间的通信过程中保持合理的响应时间和吞吐量。

这些问题的考虑将有助于确保构件之间的顺畅通信、可靠性和互操作性，从而实现良好的软件架构。



#### 8.2 构件框架概念

**构件框架（Component FrameWork）**

构件框架（Component framework）是一种用于简化应用程序开发的工具，它提供了一套通用的功能和结构，用于简化应用程序的开发过程。构件框架通常提供了一组预定义的组件和工具，用于处理常见的开发任务，如依赖注入、对象的生命周期管理、事件处理、配置管理等。它们帮助开发人员更加专注于业务逻辑，而不必过多关注底层的实现细节。

Spring框架是一个典型的构件框架。它是一个开源的Java框架，用于构建企业级应用程序。Spring框架提供了广泛的功能和组件，包括依赖注入（Dependency Injection）、面向切面编程（Aspect-Oriented Programming）、事务管理、Web应用开发、安全性等。通过使用Spring框架，开发人员可以更加高效地开发可维护、灵活、可测试的应用程序。



**构件框架体系结构的特性**

- 由一组平台决策、组构建框架和构件框架之间的互操作设计组成，平台是允许在其 上安装构件和构件框架的一个基础设施

- 一种专用的体系结构，常常实现—些协议以连接构件。

- 多数原子构件永远都不会被单独部署’尽管它们可以被单独部署。



#### 9.3 开发构件

**获取构件/框架的方式**

1. 从现有构件中获得符合要求的构件，直接使用或作适应性修改得到可复用的构件。
2. 通过遗留工程(Legacy Engineenng)中，将具有潜在复用价值的软件提取出来,得到可复用的构件。
3. 从市场上购买现成的商业构件框架。
4. 自己新开发一个适用于领域属性的构件框架。



**开发构件的策略**

1. 分区：分区策略指的是将问题情景的空间分割成几乎可以独立研究的部分，每个模块负责处理特定的功能或任务。这种策略的目的是将系统的不同部分进行逻辑上的分离，以便更容易理解和管理。
2. 抽象：抽象策略指的是对给定实践内软硬件计算单元的一种抽象，即提取出系统中的通用功能和模式，并将其定义为抽象构件或接口。这些抽象构件可以在系统中的多个部分进行共享和重用，从而减少了重复代码的编写，并提高了系统的灵活性和可扩展性。
3. 分割：分割策略将是将结构引入入构件的行为，支持对行为性质进行时序推理。根据行为功能对系统进行切割，将其拆分为更小的模块或组件。这种策略可以根据系统的结构、功能或技术进行划分。分割可以提高系统的模块化程度，使得每个模块相对独立，还有助于团队合作和维护，因为不同的开发人员可以专注于自己负责的构件。



**开发构件的步骤**

基于构件的开发模型包括软件的需求分析定义、体系结构设计、构件库建立、应用软件构建以及测试和发布5个顺序执行的阶段°



**构件组装的失配问题**

构件组装过程中需要检测并解决架构失配问题：

- 构件失配主要包括由系统对构件基础设施、控制模型和数据模型的假设存在冲突引起的失配,。

- 连接子失配包括由系统对构件交互协议、构件连接时数据格式的假设存在冲突引起的失配。

### 九、构件平台与典型架构

#### 9.1 构件平台概念

**经典的构件平台**

几乎没有构件会单独部署，他们几乎都依赖于特定的基础设施平台，最经典的如下

1. CORBA（Common Object Request Broker Architecture）：由OMG（Object Management Group）制定的一种面向对象的通信中间件标准。它定义了一组标准接口和协议，用于支持分布式系统中不同编程语言和平台之间的通信和交互。

2. COM/DCOM（Component Object Model/Distributed Component Object Model）：由Microsoft制定的一种面向对象的组件技术标准。COM定义了一组规范，用于构建可重用的软件组件，而DCOM扩展了COM，支持跨网络的分布式组件通信。

3. EJB（Enterprise JavaBeans）：由SUN（现在的Oracle）的Java企业Bean制定的一种Java平台的分布式组件模型标准。EJB定义了一组规范，用于构建基于Java的企业级应用程序组件，提供事务管理、持久化、安全性等功能。

这些构件标准都旨在提供一种标准化的方法来开发和集成软件组件，以实现跨平台、跨语言和跨网络的互操作性。它们提供了一些通用的接口和协议，使不同的组件可以相互通信和协同工作，从而简化了软件开发和系统集成过程。

#### 9.2 OMG的方式

**OMG（Object Management Group）构件平台**

是一套由OMG组织定义和管理的构件技术标准。OMG是一个国际性的标准化组织，致力于制定面向对象技术和分布式计算领域的标准。

OMG构件平台的核心概念是基于组件的开发和部署。它提供了一组标准规范，用于构建、集成和管理可重用的软件构件，从而实现分布式系统的开发和部署。

OMG构件平台的主要技术标准包括：

1. CORBA（Common Object Request Broker Architecture）：CORBA是OMG定义的一种面向对象的通信中间件标准，用于支持分布式系统中不同编程语言和平台之间的通信和交互。

2. IDL（Interface Definition Language）：IDL是OMG定义的一种接口描述语言，用于描述构件的接口和方法。它提供了一种中立的、语言无关的接口定义方式，使得不同语言和平台之间可以相互通信和交互。

3. UML（Unified Modeling Language）：UML是OMG定义的一种建模语言，用于描述构件的结构、行为和关系。它提供了一种统一的、标准化的建模方法，使得开发人员可以更好地理解和设计构件。

通过使用OMG构件平台的标准和规范，开发人员可以将不同的构件组合在一起，构建复杂的分布式系统。这些构件可以在不同的平台和环境中运行，并通过CORBA进行通信和交互。OMG构件平台提供了一种通用的、标准化的方法来开发和部署分布式系统，提高了系统的可重用性、互操作性和扩展性。



**CORBA**

CORBA（Common Object Request Broker Architecture）是一种面向对象的通信中间件架构，它提供了一套标准化的接口和协议，用于支持不同编程语言和平台之间的分布式对象通信和交互。

它的目标是 ： 使不同语言、不同实验、不同平台之间能够互相交互。

CORBA的组成：一套调用接口、对象请求代理，一套对象适配器

#### 9.3 SUN公司的方式

**Bean模型**

Bean模型是Java中一种常见的组件模型，用于构建可重用的Java组件。JavaBean是一种普通的Java类，它遵循一些特定的命名和约定，以便能够在各种Java开发环境中使用和管理。

以下是JavaBean模型的一些特点和约定：

1. 类结构：JavaBean是一个普通的Java类，通常包含私有字段（private fields）和公共访问方法（public accessor methods）。字段通常使用私有访问修饰符（private）来封装数据，而访问方法则使用公共访问修饰符（public）。

2. 属性访问方法：JavaBean使用属性访问方法（getter和setter方法）来操作和访问字段的值。这些方法遵循命名约定，例如对于一个名为"foo"的字段，对应的getter方法应该是"getFoo()"，setter方法应该是"setFoo()"。

3. 自检&定制：通过组装工具能够识别Bean、并对bean的属性行为进行定制。

4. 可序列化与持久化：JavaBean可以实现Java的Serializable接口，以便能够在网络传输或持久化存储中进行序列化和反序列化操作。也能够持久化存储下来

5. 事件处理：JavaBean可以支持事件处理机制，即通过事件监听器（Event Listeners）来监听和处理事件。事件可以是来自外部环境的用户交互、状态变化等。

JavaBean模型的设计目的是为了提供一种可重用和可配置的组件模型，使得JavaBean可以在不同的开发工具和框架中使用，如图形用户界面（GUI）构建工具、持久化框架等。通过使用JavaBean模型，开发人员可以更加灵活地构建和组合各种组件，提高代码的可维护性和可复用性。



**Java构件模型**

下面是关于Java构件模型中提到的几种构件的简要说明：

1. Applet（小程序）：Applet是一种可以在网页中嵌入的小型Java应用程序。它运行在支持Java插件的浏览器中，并能够提供交互式和动态的内容。Applet已经在Java SE 9中被标记为过时，现在更常见的是使用其他技术，如HTML5和JavaScript，来实现网页中的交互性。

2. JavaBean（Java组件）：JavaBean是一种可重用的Java组件模型，它是一种普通的Java类，遵循特定的命名和设计规范。JavaBean类具有私有的属性（成员变量），公共的无参构造函数，以及通过getter和setter方法来访问和修改属性。JavaBean通常用于封装和传递数据，可以在各种应用程序中使用。

3. EJB（Enterprise JavaBeans）：EJB是一种用于开发分布式企业应用程序的Java组件模型，它提供了一种面向对象的编程模型和一系列服务，用于处理企业级需求，如事务管理、远程访问和安全性。EJB构件通常部署在Java EE应用服务器上，并由容器来管理其生命周期和行为。

4. Servlet（服务器端组件）：Servlet是一种Java编写的服务器端组件，用于处理客户端（通常是Web浏览器）发起的HTTP请求，并生成动态的Web内容。Servlet运行在Java Web服务器中，它们可以接收和处理请求，读取和修改请求参数，生成响应并发送回客户端。Servlet在Web应用程序开发中扮演着重要的角色。

5. 应用客户端构件：应用客户端构件是一种独立运行的Java程序，通常作为客户端应用程序在用户的计算机上执行。它们与服务器进行通信，获取数据并执行相关业务逻辑。应用客户端构件通常使用Java SE平台上的GUI库（如Swing）来创建用户界面，与用户进行交互。

这些构件代表了Java构件模型中的不同角色和用途。它们在不同领域和应用程序类型中发挥着重要的作用，用于构建各种Java应用程序，从简单的小程序到复杂的企业级应用。在现代企业级Java开发中，尽管这些传统的构件模型仍然有一定的应用，但也有其他更为流行和广泛使用的技术和框架。例如Spring

#### 9.4 Microsoft的方式

**OCM组件对象模型**

Component Object Model（组件对象模型），是微软平台上构件的基础关联模型。COM是一种面向对象的二进制接口标准，用于组件间的通信和交互。COM提供了一种标准的接口定义和调用协议，使得不同语言和技术的组件可以相互通信和协同工作。它在Windows操作系统上广泛使用，包括桌面应用程序、服务、驱动程序和其他系统组件等。

以下是COM的一些主要特点：

1. 二进制接口：COM定义了一种二进制接口规范，组件通过接口进行交互。接口定义了一组方法和属性，组件可以通过调用接口的方法来实现功能。

2. 组件重用：COM鼓励组件的重用和组合。组件可以以独立的方式开发、部署和更新，然后通过接口在应用程序中使用。

3. 接口调用：COM使用特定的调用协议进行接口的调用。调用可以是本地的（在同一进程中）或远程的（在不同进程或计算机中），COM提供了透明的方式来处理这些调用。

4. 注册和发现：COM组件需要在系统中注册，注册表中包含了组件的信息。应用程序可以使用注册表来发现和实例化需要的组件。

5. 强类型语言支持：COM可以与各种编程语言进行交互，包括C++、C#、Visual Basic等。COM定义了一套规范，使得这些语言可以访问和使用COM组件。

虽然COM是微软平台上的重要关联模型，但随着时间的推移，微软推出了其他技术和框架，如.NET和Windows Runtime（WinRT），这些新技术提供了更加现代化和灵活的构件模型。



**Net框架**

.NET框架是由微软公司开发的一种跨平台应用程序框架。它提供了一系列工具、库和运行时环境，用于开发、部署和运行各种类型的应用程序，包括Web应用、桌面应用、移动应用和云服务等。

以下是.NET框架的一些主要特点和组件：

1. 公共语言运行时（Common Language Runtime，CLR）：CLR是.NET框架的核心组件之一，它提供了应用程序的执行环境和各种运行时服务。CLR负责将.NET程序编译为中间语言（Intermediate Language，IL），并在运行时进行即时编译和执行。

2. 统一类型系统（Common Type System，CTS）：CTS定义了在.NET框架中所有语言和组件之间的类型系统，确保它们可以相互交互和使用。CTS提供了一致的数据类型和对象模型，使得不同语言编写的组件可以无缝地协同工作。

3. 类库（Framework Class Library，FCL）：FCL是.NET框架中的标准类库，提供了丰富的预定义类、接口和方法，用于开发各种应用程序。FCL包括用于处理字符串、文件、网络、安全、数据库访问等方面的类和组件。

4. ASP.NET：ASP.NET是.NET框架中用于开发Web应用程序的模块。它提供了一种基于事件驱动的编程模型，允许开发者使用不同的语言（如C#、VB.NET）编写动态的Web应用。ASP.NET支持页面生命周期、服务器控件、数据绑定、认证和授权等功能。

5. Windows Forms：Windows Forms是.NET框架中用于构建桌面应用程序的模块。它提供了一套可视化的用户界面组件，开发者可以使用这些组件来创建Windows应用程序。Windows Forms支持事件驱动编程、窗体管理、用户输入处理等功能。

6. ADO.NET：ADO.NET是.NET框架中的数据访问技术，用于与各种数据源（如数据库）进行交互。它提供了一套高性能的数据访问组件，包括连接管理、命令执行、数据读取和写入等功能。

.NET框架具有跨平台的能力，微软还推出了.NET Core，它是.NET框架的轻量级和开源版本，可以在Windows、Linux和macOS等操作系统上运行。.NET Core具有更快的性能、更小的内存占用和更好的可扩展性，适用于云原生和跨平台应用的开发。

### 十、信息安全技术与架构

#### 10.1 信息安全体系

**建立信息安全保证体系**

- 建立统一的身份认证体系
- 建立统一的信息安全管理体系
- 建立规范的信息安全保密体系
- 建立完善的网络边界防护体系

**安全管理技术**

为了取保计算机能够持续正常的运行，安全管理技术的内容包括：

- 安全设备管理
- 安全策略管理
- 安全分析控制
- 安全审计

安全保护条例包括：

- 实体安全
- 网络通信安全
- 软件与信息安全
- 管理与制度安全
- 安全技术措施

主要解决的问题有：

- 集中化的安全管理策略
- 实时的安全监控
- 安全联动机制
- 配置与补丁管理
- 统一的权限管理



#### 10.2 信息安全技术

**对称加密和非对称加密**

对称加密和非对称加密是两种常见的加密算法，用于保护数据的机密性。它们在加密和解密过程中使用不同的密钥管理方式，具有不同的特点和应用场景。

1. 对称加密（Symmetric Encryption）：
   - 对称加密使用相同的密钥来进行加密和解密数据。
   - 发送方和接收方必须共享相同的密钥才能正确地加密和解密数据。
   - 对称加密算法执行速度快，适用于大量数据的加密和解密。
   - 常见的对称加密算法包括DES、AES和RC4等。

2. 非对称加密（Asymmetric Encryption）：
   - 非对称加密使用一对密钥，即公钥和私钥，来进行加密和解密数据。
   - 公钥用于加密数据，私钥用于解密数据。
   - 发送方使用接收方的公钥进行加密，接收方使用自己的私钥进行解密。
   - 非对称加密算法提供了更高的安全性和密钥管理的灵活性。
   - 常见的非对称加密算法包括RSA和ECC等。

对称加密和非对称加密在应用中通常结合使用，以实现更高级别的数据保护：

- 对称加密用于加密大量数据，因为它的执行速度更快。
- 非对称加密用于实现密钥交换和数字签名等场景，以保证密钥的安全性和身份的验证。

一种常见的应用方式是使用非对称加密算法来加密对称加密算法使用的密钥，然后使用对称加密算法来加密实际的数据。这种组合的方式兼顾了安全性和效率。

总结起来，对称加密和非对称加密在加密和解密过程中使用不同的密钥管理方式，适用于不同的应用场景。对称加密速度快但密钥管理需要注意安全性，非对称加密提供了更高的安全性和灵活性。

**经典的加密算法**

对称加密

1. DES（Data Encryption Standard）：是一种使用56位密钥（分组数64 ，8个是奇偶校验位）的对称加密算法，已经被认为是不安全的，现已被 AES 取代。
2. IDEA 算法使用相同长度的密钥（128位）和固定长度的数据块（64位）进行操作。运行简单速度快，但受专利保护，使用范围较小。
3. AES（Advanced Encryption Standard）：是一种高级加密标准，使用128位、192位或256位密钥的对称加密算法，目前被广泛使用并被认为是安全可靠的。

非对称加密

1. RSA（Rivest-Shamir-Adleman）：是一种基于大素数分解的非对称加密算法，使用公钥加密、私钥解密，或者私钥加密、公钥解密。RSA 算法被广泛应用于数字签名和密钥交换等场景。
2. ECC（Elliptic Curve Cryptography）：是基于椭圆曲线数学原理的一种非对称加密算法，相对于 RSA 算法，ECC 在提供相同安全性的前提下使用更短的密钥长度，减少了计算和存储开销。

**流加密与块加密**

流加密和块加密是两种常见的对称加密算法模式，它们具有以下特点：

流加密的特点：
1. 实时处理：流加密算法以连续的比特流作为输入，并实时加密或解密数据流，逐个比特地处理数据。
2. 逐位处理：流加密算法对数据流进行逐位或逐字节处理，通常以连续的方式加密和解密数据。
3. 速度较快：由于逐位处理和连续加密的特点，流加密算法通常具有较快的加密和解密速度。
4. 实时性要求：流加密适用于需要实时加密和流式传输数据的场景，如实时通信、流媒体传输等。
5. 数据唯一性：相同的明文和密钥下，每次产生的密文都是不同的，流加密算法提供了唯一的数据流。

块加密的特点：
1. 分块处理：块加密算法将明文数据分为固定大小的数据块，每个数据块进行独立的加密和解密操作。
2. 固定大小的块：块加密算法通常采用固定的加密轮次和密钥进行加密和解密处理，每个数据块的长度与算法的分组大小一致。
3. 批量处理：块加密适用于对大文件或大数据块进行批量加密和解密的场景。
4. 加密延迟：块加密需要等待整个数据块完整后才能进行加密和解密，可能引入一定的延迟。
5. 数据一致性：在相同的明文和密钥下，同一个数据块的加密结果始终相同，块加密算法提供了可重复的加密过程。

需要根据具体的应用需求、安全性要求和性能要求来选择适当的加密模式，流加密适用于实时性要求高的场景，而块加密适用于大量数据的批量加密和解密需求。



数据库的加解密 API和透明加密

(l)加解密API:数据库管理系统提供可在SQL语句中显示地调用的加解密API，应用可以利用这

些API构建自己的基础架构’对敏感数据进行加密，以保护数据的机密性。

(2)透明加密:安全管理员为数据库敏感字段选择加密方式及密钥强度’。数据库管理系统（DBMS）自动对数据进行加密和解密，对应用程序来说，数据的加解密过程是透明的，在表级、列级或者文件级别进行，对数据进行全面的加密保护。

 加解密API方式的灵活性强，但构建和管理复杂;而透明加密方式管理简单’应用程序负担轻,但灵活性较差。用户要求尽可能减少安全管理与应用程序的负担’因此应选择透明加密方式。



**安全协议**

IPSec（Internet Protocol Security）、SSL（Secure Sockets Layer）和 PGP（Pretty Good Privacy）都是常见的安全协议，用于保护通信过程中的数据安全性。

1. IPSec：
   - IPSec 是一组用于保护 IP 网络通信的安全协议和算法。
   - IPSec 提供了对网络层的加密、身份验证和完整性校验等功能，可以用于保护 IP 数据包的传输安全。
   - IPSec 可以在两个通信节点之间建立安全的虚拟私有网络（VPN），使得通过公共网络进行的通信变得安全可靠。

2. SSL/TLS：
   - SSL（Secure Sockets Layer）是一种安全协议，后来演化为 TLS（Transport Layer Security）。
   - SSL/TLS 协议用于在客户端和服务器之间建立安全的通信连接。
   - SSL/TLS 使用公钥加密、私钥解密和数字证书等技术来确保通信的机密性、完整性和身份验证。
   - SSL/TLS 常用于保护 Web 浏览器与服务器之间的通信，以及其他应用层协议（如 HTTPS）的安全传输。

3. PGP：
   - PGP（Pretty Good Privacy）是一种加密软件，用于保护电子邮件和文件的机密性。
   - PGP 使用非对称加密和对称加密相结合的方式来实现数据的加密和签名。
   - PGP 通过使用数字证书、公钥加密和私钥解密，以及消息摘要等技术来确保数据的安全性和完整性。
   - PGP 提供了一种用户友好的方式来实现加密和签名操作，并广泛用于保护电子邮件的隐私和安全。

这些安全协议在网络通信和数据传输过程中起到了重要的作用，提供了机密性、完整性、身份验证和防止中间人攻击等安全保护机制。具体选择哪种协议取决于应用场景、需求和安全要求的不同。



**其他安全协议的层次**

PAP 是一种用于身份验证的协议，通常用于点对点连接，例如拨号连接，工作在第二层（数据链路层）。

L2TP 是一种用于虚拟私有网络（VPN）的协议，工作在第二层（数据链路层）和第三层（网络层）之间。



**安全隔离网闸的意义**

在用户的网络需要保证高强度的安全，同时又与其他不信任网络进行信息交换的情况下，如果采用物理隔离卡，用户必须使用开关在内外网之间来回切换，不仅管理起来非常麻烦’使用起来也非常不方便。如果采用防火墙，由于防火墙自身的安全很难保证,所以防火墙也无法防止内部信息泄漏和外部病毒、黑客程序的渗入,安全性无法保证。在这种情况下安全隔离网闸能够同时满足这两个要求，弥补了物理隔离卡和防火墙的不足之处是最好的选择°

对网络地隔离是通过网闸隔离硬件，实现两个网络在链路层断开，但是为了交换数据,通过 计的隔离硬件在两个网络间进行切换通过对硬件上的存储芯片的读写,完成数据的交换。

安装了相应的应用模块之后’安全隔离网闸可以在保证安全的前提下’使用户可以测览网页、 收发电子邮件、在不同网络上的数据库之间交换数据,并可以在网络之间交换定制的文件。



#### 10.3 信息安全架构

**系统安全架构体系**

为了建立可持续改进的安全技术体系架构的能力，信息系统安全体系分为：

技术体系：

- 物理安全技术
- 系统安全技术

组织结构体系：

- 机构
- 岗位
- 人事

管理体系：

- 法律管理
- 制度管理
- 培训管理

信息系统安全规划依托于企业信息化咋略规划。

信息系统安全规划需要围绕技术安全、管理安全、组织安全。

信息系统安全规划以信息系统与信息资源的安全保护为核心。

**网络安全架构设计**

ISO网络安全体系框架：

- 鉴别框架：防止其他实体占用或独立操作被鉴别实体的身份
- 访问控制框架：决定允许使用哪些资源，在什么地方适合阻止为被授权的访问过程
- 机密性框架：确保信息仅仅是对授权者可用
- 完整性框架：通过阻止或探测威胁，保护可能遭遇不同方式危害的数据完整性或数据属性的完整性
- 抗抵赖性框架：包括证据的生成、验证、记录，在解决纠纷时随即进行数据恢复和再次验证。

**数据库安全架构设计**

数据库的安全问题已经构成信息系统最为关键的环节’而电子政务中涉及的数据库密级更高、 实时性更强°

从数据库管理系统的角度而言’采取的安全策略—般为〉用户管理、存取控制、数据加密、审计 跟踪和攻击检测°

数据库的完整性是指数据库中数据的正确性和相容性’就是数据库完整性约束的设计,通过 DBMS或应用程序来实现°

**数据库完整性设计原则**

1. 确定其实现的系统层次和方式，并提前考虑对系统性能的影响
2. 实体完整性约束、参照完整性约束是最重要的，尽量使用
3. 慎用触发器
4. 在需求分析阶段就必须制定完整性约束的命名规范
5. 要根据业务规则对数据库完整性进行细致的测试
6. 应采用合适的CASE工具来减少数据库设计各阶段的工作量

完整性设计可以分为如下三个阶段：

1. 需求分析阶段：确定系统中应该包含的对象以及其业务规则
2. 概念结构设计阶段：根据需求分析的结果，转换成对应关系类型的概念实体，以及实体间关系
3. 逻辑结构设计阶段：根据概念结构的结果，转换成对应数据模型，并对结构进行优化和规范化

有如下作用：



**GB/T9387.2—l995中定义了五大类安全服务**

分别是认证服务、访问控制服务、数据机密性服务、数据完整性服务和抗抵赖性服务。

认证服务：认证服务的基本目的是防止其他实体占用和独立操作被认证实体的身份。认证服务提供了实体声称其身份的保证，只有在主题和验证者的关系背景下,认证才有意义。认证服务的主要实现方式包括以下五种:

- 已有的信息’如认证口令

- 拥有的信息’如IC卡、令牌等

- 不可改变的特性’如指纹、虹膜等生物特征
- 相信可靠的第三方建立的认证

- 环境’如主机地址等

访问控制服务·访问控制服务决定开放环境中允许使用哪些资源、在什么地方适合组织为授权访问的过程。在访问控制实例中’访问可以对—个系统或对系统内部进行°常见的访问控制服务的实现方式包括以下三种方式:

- 自主访问控制(DAC)°自主访问控制是一种接入控制服务’通过执行基于系统实体身份及 其到系统资源的接入授权。包括在文件、文件夹和共享资源中设置许可。用户有权对自身所创建的 文件、数据表等访问对象进行访问’并可将其访问权授予其他用户或收回其访问权限°允许访问对象针对该对象访问的防控策略，通常可通过访问控制列表限定针对客体可执行的操作。

- 强制访问控制(MAC)°强制访问控制是系统强制主体服从访问控制策略,是由系统对用户 所创建的对象’按照规定的规则控制用户权限及操作对象的访问。其主要特征是对所有主体及其所控制的进程、文件、段、设备等客体实施强制访问控制。
- 基于角色访问控制(RBAC)。基于角色访问控制主要通过对角色的访问进行控制’使权限与角色相关联’用户通过成为适当角色的成员而得到其角色的权限°用户可依其责任和资格分派相 应的角色’角色可依新需求和系统合并赋予新权限’而权限也可根据需要从某角色中收回。

数据机密性服务：数据机密性服务的目的是确保信息仅仅是对被授权者可用’信息的保护 可以通过确保数据被限制于授权者获得’或通过特定方式表示数据来获得°信息的机密性主要通过 以下两种方式实现:

- 通过过禁止访问提供机密性’即可以通过访问控制’以及通过物理媒体保护和路由选择控制保 证机密性°

- 通过加密提供机密性,即防止数据泄漏在传输或存储中。加密机制包括基于对称的加密机制 和基于非对称的加密机制。



数据完整性服务：数据完整性服务的目的是通过阻止威胁或探测威胁’，保护可能遭到不同方式危害的数据完整性和数据相关属性完整性，即保证数据不以未经授权方式进行改变或损毁。数据完整性的常见实现方式包括:

- 阻止对数据传输媒介访问的机制。包括物理隔离、不受干扰的信道、路由控制、访问控制等。

- 探测对数据非授权修改的机制°包括密封、数字签名、数据重复、与密码变换相结合的数字 指纹和消息序列号等。

抵赖性服务：抗抵赖服务是提供有关特定事件或行为的证据,包括证据的生成、验证和记录，以及在解决纠纷时随即进行的证据恢复和再次验证。抗抵赖性服务的实现方式主要包括数字签名、用户认证、操作日志等技术。

### 十一、系统的可靠性分析

#### 11.1 软件系统的可靠性

**定义**

​	在规定的条件下，规定的时间内，软件错误不引起系统失效的概率，该概率是系统输入和系统使用的函数。

而运行环境、软件规模，软件的内部结构、软件的开发方法和开发环境，软件的可靠性投入都会影响其可靠性。

**可靠性定量、定性指标**

- 可靠度：在规定的条件下，和规定时间内，软件不失效的概率。
- 失效强度：单位时间内软件失效的概率
- 失效率：在运行系统未出现失效的情况下，单位时间软件失效的概率
- 平均无失效时间：从系统运行开始一直到出现第一次失效的平均时间

软件的可靠性是指用户对所使用软件性能满意程度期望。可以用可靠度、平均失效时间和失效强度等来描述。

**可靠性测试的目的**

- 确认软件是否达到可靠性的要求
- 为软件的维护和使用提供可靠性依据
- 发现软件系统中的缺陷

#### 11.2 软件系统可靠性建模与设计

**软件可靠性建模**

​	指在软件开发、测试和运维过程中，通过使用数学和统计方法，对软件系统的可靠性进行定量分析和预测的过程。可靠性建模旨在评估软件系统在给定条件下的稳定性、健壮性和持续运行能力，以帮助开发团队和管理者了解软件系统的可靠性水平，并采取相应的措施改进和优化软件质量。

软件可靠性建模通常包括以下步骤：

1. 数据收集：收集软件开发和测试过程中的故障数据和性能数据，包括故障发生时间、故障类型、故障率、故障修复时间等。

2. 数据预处理：对收集到的数据进行清洗和整理，去除异常数据和噪声，确保数据的准确性和可靠性。

3. 选择合适的模型：根据收集到的数据和可靠性需求，选择适合的可靠性模型，如种子法、失效率类、曲线拟合类、马尔可夫过程等。

4. 建立模型：根据选择的模型和数据，建立可靠性模型，并进行参数估计和模型验证。

5. 模型分析和预测：通过可靠性模型，对软件系统的可靠性进行分析和预测，得出关于系统可靠性的定量结论。

6. 结果解释：解释可靠性分析的结果，将结果用于软件质量评估、风险管理和决策制定。

软件可靠性建模是软件工程领域的重要研究内容，它可以帮助软件开发团队预测和改进软件系统的可靠性，优化软件质量和性能，提高软件用户的满意度和信任度。同时，可靠性建模也为软件项目的进展和维护提供决策支持，帮助管理者做出更加明智的决策。



**软件可靠性建模的十种方法**

1. 种子法（Seed Sampling）：在可靠性测试中，选择一小部分软件模块作为种子，根据其测试结果估计整个软件的可靠性。

2. 失效率类（Failure Rate Class）：将软件中的模块按照其失效率（故障率）进行分类，以便更好地理解软件的可靠性特征。

3. 曲线拟合类（Curve Fitting）：通过对软件故障数据进行曲线拟合，预测未来可能的故障发生情况，为软件维护和改进提供参考。

4. 可靠性增长（Reliability Growth）：根据软件的故障数据，分析和估计软件可靠性的增长情况，以便预测软件的稳定性和可靠性水平。

5. 程序结构分析（Program Structure Analysis）：通过对软件的程序结构进行分析，找出可能的错误源和故障点，提高软件的可靠性。

6. 输入域分类（Input Domain Classification）：将输入域按照其特性进行分类，以便针对不同类别的输入数据进行可靠性分析和测试。

7. 执行路径分析方法（Execution Path Analysis）：分析软件的执行路径，找出可能导致故障的关键路径，帮助提高软件的可靠性。

8. 非齐次泊松过程（Non-Homogeneous Poisson Process）：一种用于建模故障发生过程的数学方法，用于预测软件的故障率和可靠性。

9. 马尔可夫过程（Markov Process）：用于建模系统状态变化的过程，可以用于预测软件系统的可靠性和性能。

10. 贝叶斯分析（Bayesian Analysis）：利用贝叶斯统计方法，根据已有的信息和先验概率，更新软件的可靠性估计。

这些方法都是在软件可靠性研究和评估中常用的工具和技术，用于分析和预测软件系统的可靠性性能，并为软件开发和维护提供决策支持。根据具体的应用场景和可靠性需求，可以选择合适的方法进行可靠性建模和分析。

**软件建模可靠性数据**

失效时间数据、失效间隔时间数据、分组时间内的失效数以及分组时间的累积失效数是在可靠性工程和可靠性建模中经常用到的概念：

1. 失效时间数据（Failure Time Data）：失效时间数据是指在可靠性测试或运行过程中，记录软件或系统发生故障的时间点或时刻。对于每个故障事件，都有一个对应的失效时间记录。

2. 失效间隔时间数据（Failure Interval Data）：失效间隔时间数据是指在可靠性测试或运行过程中，记录相邻两个故障事件之间的时间间隔。也就是记录连续两次故障之间的时间差。

3. 分组时间内的失效数（Number of Failures in Time Interval）：在可靠性测试或运行过程中，将时间分成若干个固定的时间段（分组），然后记录每个时间段内发生的故障次数，即为分组时间内的失效数。

4. 分组时间的累积失效数（Cumulative Number of Failures in Time Interval）：在可靠性测试或运行过程中，计算每个时间段结束时的累积失效数。累积失效数是指在某个时间段结束时，从开始时间到该时间点的总故障次数。

这些数据通常用于构建可靠性模型，通过对故障时间数据和失效间隔时间数据进行分析，可以了解软件或系统的可靠性特性，预测未来的故障发生情况，为软件维护和改进提供依据。同时，在可靠性测试和验证中，分组时间内的失效数和分组时间的累积失效数可以用于评估软件的稳定性和可靠性性能。



#### 11.3 软件系统可靠性设计与评价

**软件可靠性设计的方法**

容错技术：恢复块设计、N版本程序设计、冗余设计

检错技术：要考虑 检错对象、检错延迟、实现方式、处理方式四个要素

降低复杂度技术



**选择可靠性模型的方法**

- 模型假设的适用性
- 模型预测的能力与质量
- 模型使用的简便性
- 模型输出值是否满足可靠性评价的需求



**可靠性数据收集的可行方法**

- 尽早地确定可靠性模型
- 数据收集计划要有良好的可操作性
- 重视测试数据的分析和整理
- 充分利用技术手段（数据库）来进行分析和统计



## 第三篇、架构设计实践知识

### 十二、架构师的管理实践

#### 12.1 架构开发管理

**系统构想**

系统构想是指系统开发人员与用户之间的共同协议，架构师应尽早介入系统构想，这样：

- 有利于架构师对系统的认识更全面准确
- 有利于统一开发人员的思想和看法
- 有利于正确确定需求的先后顺序
- 最大程度地提高与用户的沟通，客户对设计的参与

**基于ODP的架构开发**

开放分布式处理ODP从五个标准的视点分析系统架构，包括：

- 企业业务架构
- 逻辑信息架构
- 计算接口
- 分布工程
- 技术的选择

**系统的移植与维护**

系统的移植工作大体上可以分为计划阶段、准备阶段、转换阶段、测试阶段、验证阶段。

其中：

1. 计划阶段会确立移植工作体制、移植日程、移植方法。

2. 准备阶段的工作质量对以后的软件运行效率产生很大的影响。

4. 测试阶段要核实程序在新系统中能否准确地工作。

系统的维护可以分为四种：改正性维护、适应性维护、完善性维护、预防性维护。



**VRAPS组织管理原则**

在软件架构师实践中，需要有一些原则，这些原则彼此间会相互影响。

- Vision 构想原则：像受益人描绘未来图景。（画大饼）
- Rhythm 节奏原则：定期对进度、内容、质量进行检查与规划。（催人干活）
- Anticipation 预见原则：根据现实状况推演未来，及时作出调整。（别吹太猛）
- Partnering 协作原则：识别并确保合作伙伴的有效支持。（多拉资源）
- Simplify 简化原则：了解并最小化基本架构，避免模块冗余。（费力不讨好东西的别干）



**RUP的“4+1架构视图“**

在RUP中，有一个“4+1架构视图”，是描述和建模软件系统的视图集合，从不同角度全面地理解和描述软件系统的各个方面

1. 逻辑视图（Logical View）：描述了系统的功能性方面，包括系统的组成部分、类和对象、模块化和数据流等。逻辑视图主要关注软件系统的静态结构。
2. 实现视图（Implementation View）：展示了软件系统如何被构建，包括组织代码、模块之间的依赖关系、构建和编译等。实现视图主要关注系统程序的静态组织结构。
3. 进程视图（Process View）：描述了软件系统在运行时的动态行为，包括系统的并发性、进程、任务和线程等。进程视图主要关注软件系统的运行时行为。
4. 部署视图（Deployment View）：展示了软件系统的物理部署结构，包括硬件设备、网络拓扑和软件部署配置。部署视图主要关注软件系统在物理环境中的布局和配置。

“4+1架构视图”中的这四个视图共同构成了对软件系统的全面描述，而“+1”指的是用例视图（Use Case View），它是另外一个视图，强调描述系统的功能需求和用户交互。



**VRAPS详细概念**

构想确立了系统的总体方向，使节奏原则提出的协调工作顺利进行。

节奏是一个架构团体的内部及架构团体与供应者客户等之间重复出现的、可以事先预测的一系列活动。它由三个元素组成:速度、质量和内容。

预见是架构人员根据实际运行的情况、变化的技术、客户的需求来预测、验证和调整架构的程度。验证不仅局限于传统软件工程的测试，还包括对架构的测试。调整包含架构本身’也包含构架思想。

协作是架构的受益人保持—个明确的、合作的角色，并将其所提供和获得的价值最大化的程度。成功的协作不仅仅是对架构负责人而言的，合作伙伴也必须采取行动，来确定和提供预期的价值，给出特定问题的解决办法。

简化是指架构师对所作用组织和环境进行巧妙的理解和最小化，在简化架构之前必须对组织和架构进行澄清。



#### 12.2 架构项目管理

**项目管理基础概念**

项目是为提供一项独特产品、服务或成果所做的临时性努力。项目与日常维护工作是有明显差异的，它具有如下几个特点：

- 临时性（一次性）
- 特定的产品、服务或成果
- 资源的约束（三要素：时间、成本、质量）
- 有极强的目的性
- 逐步完善

项目管理就是把各种知识、技能、手段和技术应用于项目活动之中，经过启动、计划、实施、监控和收尾等阶段来达到项目要求的过程。项目团队应当将项目置于其所处的文化与社会、国际与政治以及自然环境之中加以考虑和管理。

项目管理组至少能理解和使用以下五方面的专门知识领域：

- 项目管理知识体系;
- 应用领域的知识、标准和规定;
-  项目环境知识; 
- 通用的管理知识和技能。
- 软技能或人际关系 技能。

**标准与规则**

ISO国际标准化组织认为：标准是—致同意建立并由公认的机构批准的文件，该团体提供通用的和可重复使用的规则、指南、活动或其结果的特征。而规则是政府强制的要求，变成了某一行业必须要遵守的准则。

一项规则通常也以标准的形式诞生，体现为一项为多数人选用的最佳方案，然后随着其得到广泛的采用，变成了实际的规则。



**PRINCE2和PMBOK**

1. PMBOK (Project Management Body of Knowledge):
PMBOK是由美国项目管理学会（Project Management Institute，简称PMI）开发和维护的项目管理标准。它是一本详细的指南，涵盖了项目管理领域的各种知识、技能和最佳实践。PMBOK指南描述了项目管理的五个过程组（启动、规划、执行、监控与控制、收尾）以及十个项目管理知识领域（范围、时间、成本、质量、资源、沟通、风险、采购、相关方和整合管理）。PMBOK在项目管理社区中被广泛认可，并被用作PMP（项目管理专业人士）等认证考试的基础。

2. PRINCE2 (Projects in Controlled Environments):
PRINCE2是一种由英国政府推出的项目管理方法论，用于帮助组织有效地管理各种类型的项目。PRINCE2强调项目的控制、组织和管理，它将项目划分为（项目准备流程、项目指导流程、项目启动流程、阶段控制流程、 阶段边界管理、产品交付管理流程、项目收尾流程）7个过程。并明确定义了项目经理、项目委员会和相关利益相关者的角色和职责。PRINCE2强调在项目的生命周期中对项目的持续监控和调整，以确保项目按时、按预算和按要求交付。PRINCE2以原则、流程、主题和项目环境为关键要素。

PMBOK和PRINCE2都是项目管理方法论，用于指导和规范项目的执行和管理。它们都是在不同国际机构或组织中广泛使用的项目管理标准。它们有不同的出发点和应用范围。PMBOK更加广泛，涵盖了项目管理的多个知识领域，而PRINCE2则更加专注于结构化的项目流程管理和组织。



**项目投入有关曲线**

<img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230723195356948.png" alt="image-20230723195356948" style="zoom:50%;" />



<img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230723195301414.png" alt="image-20230723195301414" style="zoom:50%;" />

**从职能型到项目型**

有一些企业或公司的人员长期做着重复的维护与简单的开发工作，这被我们称之为职能型组织。而还有一些公司，它们的工作内容就是一个接着一个的项目，每个项目都有其特定的目标和周期限制，这被我们称之为项目型组织。这二者代表了两个极端，因为大多数公司都同时具有职能和项目这两种运行方式的影子，只不过是占比多少而已。这种占比或偏好可以体现在如下几个部分：

- 组织中全职参与项目工作的职员占比
- 项目经理和普通经理的比例
- 项目经理的头衔和权力

因此也产生了弱、强、平衡型矩阵型组织、

**项目过程组**

项目管理过程可以划分为项目启动、制订项目计划、指导和管理项目执行、监督和控制项目工作、项目收尾五个过程组。

1. 启动过程组定义并批准项目或项目阶段，包括“制定项目章程”和“识别项目干系人” 两个过程。

2. 计划过程组定义和细化目标，并为实现项目而要达到的目标和完成项目要解决的问题范围而规划必要的行动路线。
3. 执行过程组整合人员和其他资源在项目的生命期或某个阶段执行项目管理计划。
4. 监督控制过程组要求定期测量和监控项目绩效情况’识别与项目管理计划的偏差, 以便在必要时采取纠正措施’确保项目或阶段目标达成。
5. 收尾过程组正式验收产品、服务或工作成果’有序的结束项目或项目阶段。



#### 12.3 系统项目生命周期模型

**瀑布模型**

模型不灵活,特别是无法解决软件需求不明确问题’由需求不明确导致的问题有可能在项目后期才 能发现,但损失已经造成。

适用于需求明确，很少变更的项目

**螺旋模型**

螺旋模型将瀑布模型的线性顺序和快速原型的迭代结合起来，强调了其他模型所忽视的风险分析。特别适合于大型复杂的系统它的特点之一是循环反复，逐步加深系统定义和实现的深度。第二个特点是确定一系列的里程碑以确保项目朝着正确的方向前进。

适用于庞大而复杂，风险较高的项目

**迭代模型**



**V模型**

主要思想是开发和测试同等重要’左侧代表开发活动’右侧代表测试活动。与瀑布模型不同的是有多个测试级别与开发阶段相对应，适用于需求明确，需求变更不频繁的情景。

**快速原型法**

原型法认为很难立即全面准确地提出用户需求的情 况下’ 首先不要求对系统作全面、详细的调查、分析而是本着开发人员对用户需求的初步理解，快速开发一个原型系统’然后通过反复修改来实现用户的最终的系统需求。特点归纳如下：

- 实际可运行。
- 具有最终系统的基本特征。
- 构造方便、快速，造价低。

适用于需求不太明确的项目

### 十三、层次系统架构设计

#### 13.1 体系结构设计

**软件体系结构**

软件体系结构为一个软件系统的属性、行为和结构提供了高级抽象。主要由元素的描述、元素的相互作用、元素的组织模式以及模式的约束组成。它帮助软件开发人员和利益相关者更好地理解系统的整体设计和功能，主要从以下三个方面考察: 

- 利益相关人员之间的交流：提供通用的抽象框架，可以帮助不同方面利益的相关者就系统的整体结构和功能进行有效的讨论，从而协调各方的意见，提高沟通效率，降低沟通误差。
- 系统设计的前期决策：通过在体系结构层面上进行决策，可以降低后续系统开发过程中的风险和成本，这些决策会对系统的整体结构和性能产生深远的影响。
- 可传递的系统级抽象：通过建立和传递这种抽象，可以促进软件开发领域的知识共享和经验积累。同时，可传递的系统级抽象还有助于降低软件开发的复杂性，提高开发效率。

#### 13.2 表现层设计

**MVC的协作关系**

使用MVC来设计表现层有以下优点:

- 允许不同用户快速扩展界面

- 用户界面更加灵活强大
- 分层的系统也更易于维护

<img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230726004301098.png" alt="image-20230726004301098" style="zoom:50%;" />



**基于XML的界面管理**

<img src="/Users/lichuang/Library/Application Support/typora-user-images/image-20230726004318021.png" alt="image-20230726004318021" style="zoom:50%;" />

#### 13.3 业务逻辑层设计

**业务逻辑层框架**

- 领域模型对象
- 数据服务对象、业务过程实现对象
- 控制器服务对象

**业务逻辑层工作流设计**

- 过程定义导入导出接口

- 客户端应用调用接口

- 服务端应用调用接口

- 工作流（业务链路）协作接口

- 管理和监视接口

#### 13.4 数据访问层设计

**五种数据访问方式**

1. 在线访问，这是最基本的数据访问模式，也是最常用的。 
2. DataAccessOhject，DAO是标准J2EE设计模式之一。有以下组件:—个DAO工厂类;—个DAO接口;，个实现了DAO接口的具体类;数据传输对象。
3. 对象/关系映射(ObjecIIRelationMapping)。
4. 离线访问。

**程序在线访问和ORM的比较**

数据库程序在线访问方式的优点：

- 是可以处理复杂的Select语句
- 二是性能比直接的SQL 要优越—些。

数据库程序在线访问方式的缺点:

- 是在修改维护上相对困难;
- 是开发的程序员必须能看懂SQL语句。

ORM方式的优点:

- 是降低学习和开发成本
- 是减少程序代码量
- 是降低由SQL代码质量差带来的影响;
- 是程序员不用再写SQL语句进行数据库操作。

 ORM方式的缺点：

- 处理复杂查询有一定的难度
- 是性能比直接用SQL差一些。

### 十四、企业集成架构设计

#### 14.1 企业集成平台及实现

**企业集成平台**

企业集成平台是企业信息化系统集成的一套软件技术、工具和框架，用于在组织内部实现各种资源、数据、应用和系统的集成。企业集成平台的目标是优化业务流程、增强数据共享，并提高整体效率。有如下基本功能：

- 通信服务
- 信息集成服务
- 应用集成服务
- 二次开发工具
- 平台运行管理工具

**企业集成技术的发展趋势**

1. 企业信息系统集成从2层到N层：复杂度越来越高
2. 集成的方式分为面向过程、面向服务：种类越来越多
3. 集成规范的标准程度提高：方法论越来越完善
4. 集成粒度和耦合度编号：集成的单元越来越灵活

**企业集成的维度**

企业集成自顶向下可以分为：企业（会聚）集成、应用集成、数据集成、网络集成

其中的企业（会聚）集成模式可以分为：前端集成模式、后端集成模式、混合集成模式

应用集成模式可以分为：适配器集成模式、信使集成模式、面板集成模式、代理集成模式

**企业数据集成**

企业集成平台的首要目的是实现数据集成，使不同的软件应用、系统和数据能够无缝地交互和共享信息。数据集成主要有三种模式：

1. 数据联邦：数据联邦是一种集成模式，它允许在不移动或复制原始数据的情况下，通过查询和访问数据源来进行数据集成。这意味着数据仍然保留在原始的数据存储位置，而企业集成平台通过访问这些数据源来提供统一的数据视图。
2. 数据复制：数据复制是将数据从一个数据源复制到另一个数据存储位置的集成模式。通过数据复制，数据可以在多个系统之间实时或定期同步，从而实现数据的一致性和可用性。
3. 基于接口技术的数据集成：这是通过使用应用程序接口（API）或其他接口技术来实现数据集成的模式。通过接口，不同的应用程序可以相互通信和交换数据，实现系统之间的集成。


